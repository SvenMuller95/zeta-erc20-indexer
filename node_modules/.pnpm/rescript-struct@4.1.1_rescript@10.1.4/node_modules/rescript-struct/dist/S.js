'use strict';

var Js_exn = require('rescript/lib/js/js_exn.js');
var S$RescriptStruct = require('./../src/S.bs.js');
var Caml_js_exceptions = require('rescript/lib/js/caml_js_exceptions.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var Js_exn__namespace = /*#__PURE__*/_interopNamespaceDefault(Js_exn);
var S$RescriptStruct__namespace = /*#__PURE__*/_interopNamespaceDefault(S$RescriptStruct);
var Caml_js_exceptions__namespace = /*#__PURE__*/_interopNamespaceDefault(Caml_js_exceptions);

// Generated by ReScript, PLEASE EDIT WITH CARE

class RescriptStructError extends Error {
      constructor(message) {
        super(message);
        this.name = "RescriptStructError";
      }
    }

function fromOk(value) {
  return {
          success: true,
          value: value
        };
}

function fromError(error) {
  return {
          success: false,
          error: error
        };
}

var structOperations = {};

function fail$1(reason) {
  return S$RescriptStruct__namespace.fail(undefined, reason);
}

function parse(data) {
  var struct = this;
  try {
    return fromOk(S$RescriptStruct__namespace.parseAnyOrRaiseWith(data, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions__namespace.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct__namespace.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct__namespace.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function parseOrThrow(data) {
  var struct = this;
  try {
    return S$RescriptStruct__namespace.parseAnyOrRaiseWith(data, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions__namespace.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct__namespace.Raised) {
      throw new RescriptStructError(S$RescriptStruct__namespace.$$Error.toString(error._1));
    }
    throw error;
  }
}

function parseAsync(data) {
  var struct = this;
  return S$RescriptStruct__namespace.parseAnyAsyncWith(data, struct).then(function (result) {
              if (result.TAG === "Ok") {
                return fromOk(result._0);
              } else {
                return fromError(new RescriptStructError(S$RescriptStruct__namespace.$$Error.toString(result._0)));
              }
            });
}

function serialize(value) {
  var struct = this;
  try {
    return fromOk(S$RescriptStruct__namespace.serializeToUnknownOrRaiseWith(value, struct));
  }
  catch (raw_error){
    var error = Caml_js_exceptions__namespace.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct__namespace.Raised) {
      return fromError(new RescriptStructError(S$RescriptStruct__namespace.$$Error.toString(error._1)));
    }
    throw error;
  }
}

function serializeOrThrow(value) {
  var struct = this;
  try {
    return S$RescriptStruct__namespace.serializeToUnknownOrRaiseWith(value, struct);
  }
  catch (raw_error){
    var error = Caml_js_exceptions__namespace.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === S$RescriptStruct__namespace.Raised) {
      throw new RescriptStructError(S$RescriptStruct__namespace.$$Error.toString(error._1));
    }
    throw error;
  }
}

function transform(parser, serializer) {
  var struct = this;
  var struct$1 = S$RescriptStruct__namespace.transform(struct, parser, undefined, serializer, undefined);
  return Object.assign(struct$1, structOperations);
}

function refine(parser, serializer) {
  var struct = this;
  var struct$1 = S$RescriptStruct__namespace.refine(struct, parser, undefined, serializer, undefined);
  return Object.assign(struct$1, structOperations);
}

function asyncRefine(parser) {
  var struct = this;
  var struct$1 = S$RescriptStruct__namespace.refine(struct, undefined, parser, undefined, undefined);
  return Object.assign(struct$1, structOperations);
}

function describe(description) {
  var struct = this;
  var struct$1 = S$RescriptStruct__namespace.describe(struct, description);
  return Object.assign(struct$1, structOperations);
}

function description(param) {
  return S$RescriptStruct__namespace.description(this);
}

function $$default(def) {
  var struct = this;
  var struct$1 = S$RescriptStruct__namespace.$$default(struct, def);
  return Object.assign(struct$1, structOperations);
}

function string$1(param) {
  var struct = S$RescriptStruct__namespace.string(undefined);
  return Object.assign(struct, structOperations);
}

function $$boolean(param) {
  var struct = S$RescriptStruct__namespace.bool(undefined);
  return Object.assign(struct, structOperations);
}

function integer$1(param) {
  var struct = S$RescriptStruct__namespace.$$int(undefined);
  return Object.assign(struct, structOperations);
}

function number$1(param) {
  var struct = S$RescriptStruct__namespace.$$float(undefined);
  return Object.assign(struct, structOperations);
}

function never$1(param) {
  var struct = S$RescriptStruct__namespace.never(undefined);
  return Object.assign(struct, structOperations);
}

function unknown$1(param) {
  var struct = S$RescriptStruct__namespace.unknown(undefined);
  return Object.assign(struct, structOperations);
}

function optional$1(struct) {
  var struct$1 = S$RescriptStruct__namespace.option(struct);
  return Object.assign(struct$1, structOperations);
}

function nullable$1(struct) {
  var struct$1 = S$RescriptStruct__namespace.$$null(struct);
  return Object.assign(struct$1, structOperations);
}

function array$1(struct) {
  var struct$1 = S$RescriptStruct__namespace.array(struct);
  return Object.assign(struct$1, structOperations);
}

function record$1(struct) {
  var struct$1 = S$RescriptStruct__namespace.dict(struct);
  return Object.assign(struct$1, structOperations);
}

function json$1(struct) {
  var struct$1 = S$RescriptStruct__namespace.json(struct);
  return Object.assign(struct$1, structOperations);
}

function union$1(structs) {
  var struct = S$RescriptStruct__namespace.union(structs);
  return Object.assign(struct, structOperations);
}

function tuple$1(structs) {
  var struct = S$RescriptStruct__namespace.Tuple.factory.apply(null, structs);
  return Object.assign(struct, structOperations);
}

function literal$1(value) {
  var taggedLiteral = typeof value === "string" ? ({
        TAG: "String",
        _0: value
      }) : (
      typeof value === "boolean" ? ({
            TAG: "Bool",
            _0: value
          }) : (
          typeof value === "number" ? (
              Number.isNaN(value) ? Js_exn__namespace.raiseError("[rescript-struct] Failed to create a NaN literal struct. Use S.nan instead.") : ({
                    TAG: "Float",
                    _0: value
                  })
            ) : (
              value === null ? "EmptyNull" : (
                  value === undefined ? "EmptyOption" : Js_exn__namespace.raiseError("[rescript-struct] The value provided to literal struct factory is not supported.")
                )
            )
        )
    );
  var struct = S$RescriptStruct__namespace.literal(taggedLiteral);
  return Object.assign(struct, structOperations);
}

function nan$1(param) {
  var struct = S$RescriptStruct__namespace.literal("NaN");
  return Object.assign(struct, structOperations);
}

function custom$1(name, parser, serializer) {
  var struct = S$RescriptStruct__namespace.custom(name, parser, undefined, serializer, undefined);
  return Object.assign(struct, structOperations);
}

Object.assign(structOperations, {
      parse: parse,
      parseOrThrow: parseOrThrow,
      parseAsync: parseAsync,
      serialize: serialize,
      serializeOrThrow: serializeOrThrow,
      transform: transform,
      refine: refine,
      asyncRefine: asyncRefine,
      optional: (function (param) {
          return optional$1(this);
        }),
      nullable: (function (param) {
          return nullable$1(this);
        }),
      describe: describe,
      description: description,
      default: $$default
    });

var objectStructOperations = {};

function strict(param) {
  var struct = this;
  return Object.assign(S$RescriptStruct__namespace.$$Object.strict(struct), objectStructOperations);
}

function strip(param) {
  var struct = this;
  return Object.assign(S$RescriptStruct__namespace.$$Object.strip(struct), objectStructOperations);
}

function factory(definer) {
  return Object.assign(S$RescriptStruct__namespace.object(function (o) {
                  var definition = {};
                  var fieldNames = Object.keys(definer);
                  for(var idx = 0 ,idx_finish = fieldNames.length; idx < idx_finish; ++idx){
                    var fieldName = fieldNames[idx];
                    var struct = definer[fieldName];
                    definition[fieldName] = S$RescriptStruct__namespace.field(o, fieldName, struct);
                  }
                  return definition;
                }), objectStructOperations);
}

Object.assign(objectStructOperations, structOperations);

Object.assign(objectStructOperations, {
      strict: strict,
      strip: strip
    });

var $$Object = {
  factory: factory
};
/*  Not a pure module */

const StructError = RescriptStructError;
const string = string$1;
const boolean = $$boolean;
const integer = integer$1;
const number = number$1;
const never = never$1;
const unknown = unknown$1;
const optional = optional$1;
const nullable = nullable$1;
const array = array$1;
const record = record$1;
const json = json$1;
const union = union$1;
const object = $$Object.factory;
const custom = custom$1;
const literal = literal$1;
const nan = nan$1;
const tuple = tuple$1;
const fail = fail$1;

exports.StructError = StructError;
exports.array = array;
exports.boolean = boolean;
exports.custom = custom;
exports.fail = fail;
exports.integer = integer;
exports.json = json;
exports.literal = literal;
exports.nan = nan;
exports.never = never;
exports.nullable = nullable;
exports.number = number;
exports.object = object;
exports.optional = optional;
exports.record = record;
exports.string = string;
exports.tuple = tuple;
exports.union = union;
exports.unknown = unknown;
